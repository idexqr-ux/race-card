<script>
  // --- Calm speech helpers (audio-first behaviour) ---
  const ttsAvailable = "speechSynthesis" in window && "SpeechSynthesisUtterance" in window;

  function calmSpeak(text){
    const status = document.getElementById("status");
    status.textContent = ttsAvailable ? "Speaking" : "Speech not available (text only)";

    // Always update the written echo (visual whisper reinforcement)
    setAnswer(text);

    if(!ttsAvailable) return;

    // Stop any previous speech
    window.speechSynthesis.cancel();

    const u = new SpeechSynthesisUtterance(text);

    // Keep it gentle; device decides the actual voice.
    u.rate = 0.95;
    u.pitch = 0.95;
    u.volume = 1;

    u.onend = () => { status.textContent = "Ready"; };
    u.onerror = () => { status.textContent = "Speech error (text shown)"; };

    window.speechSynthesis.speak(u);
  }

  function setAnswer(text){
    const a = document.getElementById("answer");
    a.textContent = text;
  }

  // --- Data stores (CSV) ---
  let LEGENDS = [];
  let GATECARD = [];
  let INDEX_BY_NO = new Map();
  let INDEX_BY_NAME = new Map();

  function clean(s){ return (s || "").toString().trim(); }
  function lower(s){ return clean(s).toLowerCase(); }

  // Simple CSV parser (supports quoted commas)
  function parseCSV(text){
    const rows = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for(let i=0; i<text.length; i++){
      const ch = text[i];
      const next = text[i+1];

      if(ch === '"' && inQuotes && next === '"'){ cur += '"'; i++; continue; }
      if(ch === '"'){ inQuotes = !inQuotes; continue; }

      if(ch === "," && !inQuotes){ row.push(cur); cur = ""; continue; }

      if((ch === "\n" || ch === "\r") && !inQuotes){
        if(ch === "\r" && next === "\n") i++;
        row.push(cur);
        if(row.some(c => clean(c) !== "")) rows.push(row);
        row = []; cur = ""; continue;
      }

      cur += ch;
    }

    row.push(cur);
    if(row.some(c => clean(c) !== "")) rows.push(row);

    if(rows.length === 0) return [];

    const headers = rows[0].map(h => lower(h));
    const out = [];

    for(let r=1; r<rows.length; r++){
      const obj = {};
      for(let c=0; c<headers.length; c++){
        obj[headers[c]] = clean(rows[r][c] ?? "");
      }
      out.push(obj);
    }
    return out;
  }

  async function loadData(){
    const statusEl = document.getElementById("status");
    try{
      statusEl.textContent = "Loading data";

      const [legTxt, gateTxt] = await Promise.all([
        fetch("legends.csv", { cache: "no-store" }).then(r => r.ok ? r.text() : ""),
        fetch("gatecard.csv", { cache: "no-store" }).then(r => r.ok ? r.text() : "")
      ]);

      LEGENDS = legTxt ? parseCSV(legTxt) : [];
      GATECARD = gateTxt ? parseCSV(gateTxt) : [];

      INDEX_BY_NO.clear();
      INDEX_BY_NAME.clear();

      GATECARD.forEach(row => {
        const no = clean(row.horse_no);
        const nm = lower(row.horse_name);
        if(no) INDEX_BY_NO.set(no, row);
        if(nm) INDEX_BY_NAME.set(nm, row);
      });

      statusEl.textContent = "Ready";
    }catch(e){
      statusEl.textContent = "Ready (data not loaded)";
    }
  }

  function findLegend(term){
    const t = lower(term);
    if(!t) return null;
    return LEGENDS.find(x => lower(x.term) === t) || null;
  }

  function findHorseFromQuestion(q){
    // Try: "horse 2", "#2", "2"
    const m = q.match(/(?:horse\s*)?#?(\d{1,2})\b/);
    if(m && INDEX_BY_NO.has(m[1])) return INDEX_BY_NO.get(m[1]);

    // Try matching horse name by containment
    for(const [nm, row] of INDEX_BY_NAME.entries()){
      if(q.includes(nm)) return row;
    }
    return null;
  }

  // --- CSV-powered "brain" (calm, short, usable aloud) ---
  function generateCalmAnswer(question){
    const raw = clean(question);
    const q = lower(raw);

    const orientation =
      "You’re in the Ask companion. I can speak answers and show a quiet written echo. " +
      "You can tap a whisper prompt, or type a short question.";

    if(!q){
      return orientation + " What would you like to know — colours, going, or a short summary?";
    }

    // “what does X mean”
    const meanMatch = q.match(/what does (.+) mean\??/);
    if(meanMatch){
      const term = clean(meanMatch[1]).replace(/[.?!]$/,"");
      const hit = findLegend(term);
      if(hit) return `${hit.term}. ${hit.meaning}.`;
      return "I don’t have that term saved yet. If you add it to legends.csv, I’ll learn it.";
    }

    // Colours
    if(q.includes("colour") || q.includes("color") || q.includes("cap") || q.includes("sleeve") || q.includes("silk")){
      const horse = findHorseFromQuestion(q);
      if(horse){
        const cap = clean(horse.cap) || "not set";
        const body = clean(horse.body) || "not set";
        const sleeves = clean(horse.sleeves) || "not set";
        return `Colours are read as cap, body, sleeves. For ${horse.horse_name}: cap ${cap}, body ${body}, sleeves ${sleeves}.`;
      }
      return "If you tell me the horse number or name, I can read the colours as cap, body, sleeves.";
    }

    // Going
    if(q.includes("going")){
      const horse = findHorseFromQuestion(q);
      if(horse && clean(horse.going)){
        const g = clean(horse.going);
        const hit = findLegend(g);
        return hit ? `Going is ${hit.meaning} (${g}).` : `Going is ${g}.`;
      }
      return "If you tell me the horse number, I can read the going saved on this card.";
    }

    // Summary / notes
    if(q.includes("summary") || q.includes("notes") || q.includes("tell me about")){
      const horse = findHorseFromQuestion(q);
      if(horse){
        const bits = [];
        bits.push(`${horse.horse_name}.`);
        if(clean(horse.age) || clean(horse.sex)) bits.push(`Age/sex: ${clean(horse.age)} ${clean(horse.sex)}.`.trim());
        if(clean(horse.trainer)) bits.push(`Trainer: ${horse.trainer}.`);
        if(clean(horse.jockey)) bits.push(`Jockey: ${horse.jockey}.`);
        if(clean(horse.notes)) bits.push(`Notes: ${horse.notes}`);
        return bits.join(" ");
      }
      return "Tell me the horse number or name and I’ll give a short, calm summary.";
    }

    return orientation + " For data answers, include a horse number (like ‘horse 2’) or ask what a term means.";
  }

  // --- Wiring ---
  const askButton = document.getElementById("askButton");
  const speakBtn = document.getElementById("speakBtn");
  const micBtn = document.getElementById("micBtn");
  const typedAsk = document.getElementById("typedAsk");
  const statusEl = document.getElementById("status");

  askButton.addEventListener("click", () => {
    statusEl.textContent = "Thinking";
    calmSpeak(generateCalmAnswer(""));
  });

  speakBtn.addEventListener("click", () => {
    statusEl.textContent = "Thinking";
    calmSpeak(generateCalmAnswer(typedAsk.value || ""));
  });

  typedAsk.addEventListener("keydown", (e) => {
    if(e.key === "Enter"){
      e.preventDefault();
      speakBtn.click();
    }
  });

  document.querySelectorAll(".chip").forEach(btn => {
    btn.addEventListener("click", () => {
      statusEl.textContent = "Thinking";
      const q = btn.getAttribute("data-q") || "";
      typedAsk.value = q;
      calmSpeak(generateCalmAnswer(q));
    });
  });

  micBtn.addEventListener("click", () => {
    calmSpeak("Voice input will be added later. For now, you can tap a whisper prompt or type a short question, then choose Speak answer.");
  });

  // Load CSV data once
  loadData();

  // Initial status
  document.getElementById("mode").textContent = ttsAvailable ? "Audio-first (TTS available)" : "Text-first (no TTS)";
</script>
